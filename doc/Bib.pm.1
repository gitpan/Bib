.rn '' }`
''' $RCSfile$$Revision$$Date$
''' 
''' $Log$
''' 
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.if t .ds PI \(*p
.if n .ds PI PI
'br\}
.TH BIB 1 "\*(RP"
.UC
.if n .hy 0 
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd S B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds / 
.	ds q 
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Text::Bib -- parse Unix \fI.bib\fR files
.SH "DESCRIPTION"
This module provides routines for parsing in the contents
of bibliographic databases (usually found lurking on Unix-like
operating systems): these are simple text files which contain
one or more bibliography records.  Each record describes a single
paper, book, or article.  Users of nroff/troff often employ 
such databases whenm typesetting papers.
.PP
Even if you don't use *roff, this simple, easily-parsed parameter-value 
format is still useful for recording/exchanging bibliographic 
information.  With the Bib:: module, you can easily post-process
\fI.bib\fR files: search them, convert them into LaTeX, whatever.
.PP
\fBIMPORTANT NOTE FOR OLD Bib:: USERS\fR:
After conversations with the High-Muckity-Mucks of the CPAN, this
module has been renamed from \fBBib::\fR to the more appropriate \fBText::Bib.\fR
.Sh "Bibliographic databases "
(From the \s-1GNU\s0 manpage, \f(CWgrefer(1)\fR:)
.PP
The  bibliographic  database  is a text file consisting of
records separated by one or more blank lines.  Within each
record  fields  start with a % at the beginning of a line.
Each field has a one character name that immediately  follows  
the  %.  It is best to use only upper and lower case
letters for the names of fields. The name  of  the  field
should  be  followed by exactly one space, and then by the
contents of the field.  Empty  fields  are  ignored.   The
conventional meaning of each field is as follows:
.Ip "A" 4
The name of an author. If the name contains a
title such as Jr. at the end, it should	be separated  
from the last name by a comma.  There can be multiple 
occurrences of the A field.  The order is significant. 
It is a good idea always to supply an A field or a Q field.
.Ip "B" 4
For an article that is part of a book, the title of the book
.Ip "C      " 4
The place (city) of publication.
.Ip "D      " 4
The date of publication.  The year should be specified in full.  
If the month is specified, the name rather than the number of 
the month should be used, but only the first three letters are required.   
It is a good idea always to supply a D field; if the date is unknown, 
a value such as \*(L"in press\*(R" or \*(L"unknown\*(R" can be used.
.Ip "E      " 4
For  an article that is part of a book, the name of an editor of the book.  
Where the work has editors and no authors, the names of the editors should 
be  given as A fields and , (ed) or , (eds)  should  be
appended to the last author.
.Ip "G      " 4
\s-1US\s0 Government ordering number.
.Ip "I      " 4
The publisher (issuer).
.Ip "J" 4
For an article in a journal, the name of the journal.
.Ip "K  " 4
Keywords to be used for searching.
.Ip "L  " 4
Label.
.Sp
\fB\s-1NOTE\s0:\fR Uniquely identifies the entry.  For example, \*(L"Able94\*(R".
.Ip "N " 4
Journal issue number.
.Ip "O      " 4
Other information.  This is usually printed at the end of the reference.
.Ip "P      " 4
Page number.  A range of pages can be specified as m-n.
.Ip "Q" 4
The name of the author, if the author is not a person.   
This will only be used if there are no A fields.  There can only be one 
Q field.
.Sp
\fB\s-1NOTE\s0:\fR Thanks to Mike Zimmerman for clarifying this for me:
it means a \*(L"corporate\*(R" author: when the \*(L"author\*(R" is listed
as an organization such as the \s-1UN\s0, or \s-1RAND\s0 Corporation, or whatever.
I've changed the access/storage/etc. methods to \*(L"corpAuthor\*(R" to access it,
but \*(L"android\*(R" will still work for now.
.Ip "R      " 4
Technical report number.
.Ip "S      " 4
Series name.
.Ip "T      " 4
Title.  For an article in a book or journal, this should be the title 
of the article.
.Ip "V      " 4
Volume number of the journal or book.
.Ip "X      " 4
Annotation.
.Sp
\fB\s-1NOTE\s0:\fR Basically, a brief abstract or description.
.PP
For all fields except A and E, if there is more than one occurrence
of a particular field in a record, only the last such field will be used.
.PP
If accent strings are used, they should follow the character 
to be accented.  This means that the \s-1AM\s0 macro must  be
used  with  the \-ms macros.  Accent strings should not be
quoted: use one \e rather than two.
.Sh "An example"
Here's a possible \fI.bib\fR file with three entries:
.PP
.Vb 14
\&    %T Cyberiad
\&    %A Stanislaw Lem
\&    %K robot fable 
\&    %I Harcourt/Brace/Jovanovich
\&    
\&    %T Invisible Cities
\&    %A Italo Calvino
\&    %K city fable philosophy
\&    %X In this surreal series of fables, Marco Polo tells an
\&       aged Kublai Khan of the many cities he has visited in 
\&       his lifetime.  
\&    
\&    %T Angels and Visitations
\&    %A Neil Gaiman               
.Ve
.Sh "For more information"
See \fIrefer\fR\|(1) or \fIgrefer\fR\|(1) for a description of \fI.bib\fR files.
.SH "USAGE"
.Sh "Parsing .bib files"
To parse a \fI.bib\fR file, just do this:
.PP
.Vb 7
\&    require Text::Bib;
\&    
\&    my $bib;                           
\&    while ($bib = Text::Bib->read($anyOldFileHandle)) {
\&        # ...do stuff with $bib...
\&    }
\&    defined($bib) || die("error parsing input");
.Ve
You will nearly always use the \f(CWread()\fR constructor to create
new instances, and nearly always as shown above.  Notice that 
\f(CWread()\fR returns the following:
.PP
.Vb 3
\&        The new object, on success.
\&        The value '0', on expected end-of-file.
\&        The undefined value, on error.
.Ve
Since \f(CWread()\fR returns \*(L"true\*(R" if and only if a new object could be read,
and it returns two distinct \*(L"false\*(R" values otherwise, it's very easy to 
iterate through a \fI.bib\fR stream \fIand\fR to know why the iteration stopped.
.PP
By default, the parser accepts any one-character field name that is
a printable character (no whitespace).  Formally, this is:
.PP
.Vb 1
\&    [\e041-\e176]
.Ve
Use of characters outside this range is a syntax error.  You may define
a narrower range using the GoodFields parser-option: however, this will
slow down your parser, so you may want to consider whether or not you 
really need it.
.Sh "Using Bib objects"
For every one of the standard fields in a \fI.bib\fR record, the Bib:: 
module has designated a high-level attribute name:
.PP
.Vb 19
\&           A    - author
\&           B    - book
\&           C    - city
\&           D    - date
\&           E    - editor
\&           G    - govtNo
\&           I    - publisher
\&           J    - journal
\&           K    - keywordList
\&           L    - label
\&           N    - number
\&           O    - otherInfo
\&           P    - page
\&           Q    - android
\&           R    - reportNo
\&           S    - series
\&           T    - title
\&           V    - volume
\&           X    - abstract
.Ve
Then, for each high-level attribute name \fIattr\fR, Text::Bib:: defines three
methods:
.Ip "attr()" 4
All access methods of this form (e.g., \f(CWdate()\fR, \f(CWtitle()\fR),
return a single scalar value for that particular attribute,
or undef if there is no such value.  For example:
.Sp
.Vb 1
\&    $date = $bib->date();
.Ve
If the Bib object has more than one value defined for \fIattr\fR,
the last value that was read in is used.
.Ip "attrs()" 4
All access methods of this form  (e.g., \f(CWdates()\fR, \f(CWtitles()\fR),
return the array of all values of that attribute, as follows:
.Sp
.Vb 2
\&        If invoked in an array context, an array of values is returned, or the empty array if there are no values for that particular attribute.
\&        If invoked in an scalar context, a B<reference to> an array of values is returned, or undef if there are no values for that particular attribute.  
.Ve
For example:
.Sp
.Vb 9
\&    # Get and print the first author in the list:
\&    (@authors = $bib->authors()) || die("no authors");
\&    print "first author = $authors[0]\en";
\&    
\&    # Virtually the same thing, but more efficient if many authors:
\&    ($authorsRef = $bib->authors()) || die("no authors");
\&    print "first author = $authorsRef->[0]\en";
\&    
\&=item setAttrs()
.Ve
All methods of this form (e.g., \f(CWsetAuthors()\fR, 
\f(CWsetEditors()\fR) set the array of all values of that attribute.
Supply the list of values as the arguments; for example:
.Sp
.Vb 1
\&    $bib->setAuthors('C. Clausticus', 'H. Hydronimous', 'F. Fwitch');
.Ve
.PP
If you are writing a subclass, you can use the \f(CWmakeMethods()\fR class
method to add new fields, or override the interpretation of
existing ones:
.PP
.Vb 16
\&    package MyBibSubclass;
\&    @ISA = qw(Text::Bib);
\&    
\&    # In our files, %Y holds the year, which is *really* the date:
\&    MyBibSubclass->makeMethods('Y', 'date');
\&    
\&    # Also in our files, %u fields hold the URLs of any on-line copies:
\&    MyBibSubclass->makeMethods('u', 'url');    
\&    
\&    ...
\&    while ($bib = MyBibSubclass->read($FH)) {
\&        $date   = $bib->date();     # return date, from %Y
\&        @urls   = $bib->urls();     # return array of URLs, from %u
\&        $anyUrl = $bib->url();      # return the last URL encountered
\&        ...
\&    }
.Ve
.Sh "Printing Bib objects"
The normal way to output Bib objects in \fI.bib\fR format is to
use the method:
.PP
.Vb 1
\&    $bib->output($filehandle);
.Ve
The filehandle may be omitted; in such a case, currently-selected filehandle 
is used.  The fields are output with \f(CW%L\fR first (if it exists), and then the 
remaining fields in alphabetical order.  The following \*(L"safety measures\*(R" 
are taken:
.PP
.Vb 2
\&        Lines longer than 77 characters are wrapped at the first whitespace character before that length.
\&        Any occurences of '%' immediately after a newline are preceded by a single space.
.Ve
These safety measures are slightly time-consuming, and are silly if you
are merely outputting a Bib object which you have read in verbatim 
(i.e., using the default parset-options) from a valid \fI.bib\fR file.
Thus, we define a faster method, without the seatbelts:
.PP
.Vb 1
\&    $bib->dump($filehandle);
.Ve
\fBWarning:\fR this method does no fixup on the values at all: they are 
output as-is.  That means if you used parser-options which destroyed any
of the formatting whitespace (e.g., \f(CWNewline=TOSPACE\fR with
\f(CWLeadWhite=KILLALL\fR), there is a risk that the output object will be 
an invalid Bib record.  
.PP
\fBNote:\fR users of 1.8 and previous releases will notice that the
\f(CWprint()\fR method is now undefined by default: it is deprecated in favor of
the perfectly-equivalent \f(CWoutput()\fR method.  If you absolutely cannot
change your method calls just yet, simply change your \*(L"require\*(R" line:
.PP
.Vb 2
\&    require Text::Bib;
\&    Text::Bib->DEFINE_PRINT_METHOD;
.Ve
That will define the deprecated \fIText::Bib::print()\fR as being equivalent to 
\fIText::Bib::output()\fR.
.SH "THE GORY DETAILS"
.Sh "Instance variables, and their encapsulation"
Each \fI.bib\fR object has instance variables corresponding to the actual
field names: for example, the \fI.bib\fR record:
.PP
.Vb 15
\&    %T The Non-Linear Existence of Menger-Sierpinski Dragons 
\&    %A S. Trurl
\&    %A L. Klapaucius
\&    %A C. Cybr
\&    %E Abbarat Hyperion
\&    %C 
\&    %K dragon nonlinear Menger Sierpinski irrational hat-rack
\&    %X Of the many varieties of non-existent dragons, perhaps the
\&    most fascinating one to not exist is the Menger-Sierpinski Dragon, 
\&    a.k.a. the Fractal Dragon.  This paper discusses how these "fragons"
\&    are, in fact, irrationally-dimensional (e.g., pi-dimensional) curves,
\&    and concludes with the proof that a nonexistent dragon which nonexists 
\&    in such an impossible manner must logically exist in conventional
\&    space -- surprisingly, as a hat-rack.
\&    %D 1996
.Ve
Would, when parsed, result in a Bib object with the following instance
variables:
.PP
.Vb 8
\&    $self->{T} = ["The Non-Linear ... Dragons"];
\&    $self->{A} = ["S. Trurl",
\&                  "L. Klapaucius",
\&                  "C. Cybr"];
\&    $self->{C} = [""];
\&    $self->{E} = ["Abbarat Hyperion"];
\&    $self->{K} = ["dragon nonlinear Menger Sierpinski irrational hat-rack"];
\&    $self->{D} = ["1996"];
.Ve
Notice that, for maximum flexibility and consistency (but at the cost of
some space and access-efficiency), the semantics of \fI.bib\fR records do
not come into play at this time: since everything resides in an array,
you can have as many \f(CW%K\fR, \f(CW%D\fR, etc. records as you like, and given them
entirely different semantics.   For example, the Library Of Boring Stuff 
That Everyone Reads (\s-1LOBSTER\s0) uses the unused \f(CW%Y\fR as a \*(L"year\*(R" field.
The parser accomodates this case by politely not choking on \s-1LOBSTER\s0
bibliographies.
.PP
The \fI.bib\fR semantics come into play in the storage/access methods... which, 
of course, you can override in subclasses.  So, while the default date-access
looks something like this:
.PP
.Vb 4
\&    sub date {
\&        my $self = shift;
\&        defined($self->{D}) ? $self->{D}[-1] : undef;
\&    }
.Ve
The \s-1LOBSTER\s0 would create a subclass LobsterBib::, and override the \fIdate()\fR 
method to be:
.PP
.Vb 4
\&    sub date {
\&        my $self = shift;
\&        defined($self->{Y}) ? $self->{Y}[-1] : undef;
\&    }
.Ve
Furthermore, since this is identical in format to a \*(L"standard\*(R" scalar-access
method, the \s-1LOBSTER\s0 could just place in \fILobsterBib.pm\fR the line:
.PP
.Vb 1
\&    LobsterBib->makeMethods('Y', 'date');
.Ve
And voila, the appropriate methods will be defined.
.Sh "Parser options"
Before you parse a Bib object, you can set certain parser options
to adjust for the peculiarities in a particular \fI.bib\fR\-flavored file.
    
Since we're trying to steer clear of package-level state information,
we pass the parser options right into the \f(CWread()\fR call, as the
optional second argument:
.PP
.Vb 6
\&    my $opts = Text::Bib->makeOpts(LeadWhite  => KEEP, 
\&                                   GoodFields => '[AEFZ]');
\&    
\&    while ($bib = Text::Bib->read($fh, $opts)) {
\&        # ...do stuff...
\&    }
.Ve
The options are as follows:
.Ip "GoodFields" 4
By default, the parser accepts any (one-character) field name that is
a printable character (no whitespace).  Formally, this is:
.Sp
.Vb 1
\&    [\e041-\e176]
.Ve
However, when compiling parser options, you can supply your own regular 
expression for validating (one-character) field names.
(\fInote:\fR you must supply the square brackets; they are there to remind 
you that you should give a well-formed single-character expression).
One standard expression is provided for you: 
.Sp
.Vb 1
\&    $Text::Bib::GroffFields  = '[A-EGI-LN-TVX]';  # legal groff fields
.Ve
Illegal fields which are encounterd during parsing result in a syntax error.
.Sp
\fB\s-1NOTE\s0:\fR You really shouldn't use this unless you absolutely need to.
The added regular expression test slows down the parser.
.Ip "LeadWhite" 4
In many \fI.bib\fR files, continuation lines (the 2nd, 3rd, etc. lines of a 
field) are written with leading whitespace, like this:
.Sp
.Vb 7
\&    %T Incontrovertible Proof that Pi Equals Three
\&       (for Large Values of Three)
\&    %A S. Trurl
\&    %X The author shows how anyone can use various common household 
\&       objects to obtain successively less-accurate estimations of 
\&       pi, until finally arriving at a desired integer approximation,
\&       which nearly always is three.                 
.Ve
This leading whitespace serves two purposes: 
.Sp
.Vb 2
\&        It makes it impossible to mistake a continuation line for a field, since % can no longer be the first character.
\&        It makes the .bib entries easier to read.
.Ve
The \f(CWLeadWhite\fR option controls what is done with this whitespace:
.Sp
.Vb 3
\&    KEEP        - default; the whitespace is untouched
\&    KILLONE     - exactly one character of leading whitespace is removed
\&    KILLALL     - all leading whitespace is removed
.Ve
See the section below on \*(L"using the parser options\*(R" for hints and warnings.
.Ip "Newline" 4
The \f(CWNewline\fR option controls what is done with the newlines that
separate adjacent lines in the same field:
.Sp
.Vb 3
\&    KEEP        - default; the newlines are kept in the field value
\&    TOSPACE     - convert each newline to a single space
\&    KILL        - the newlines are removed
.Ve
See the section below on \*(L"using the parser options\*(R" for hints and warnings.
.PP
Default values will be used for any options which are left unspecified.
.Sh "Using the parser options"
The default values for \f(CWNewline\fR and \f(CWLeadWhite\fR will preserve the
input text exactly.
.PP
The \f(CWNewline=TOSPACE\fR option, when used in conjunction with the
\f(CWLeadWhite=KILLALL\fR option, effectively \*(L"word-wraps\*(R" the text of
each field into a single line.
.PP
\fBBe careful!\fR If you use the \f(CWNewline=KILL\fR option with
either the \f(CWLeadWhite=KILLONE\fR or the \f(CWLeadWhite=KILLALL\fR option,
you could end up eliminating all whitespace that separates the word
at the end of one line from the word at the beginning of the next line.
.Sh "Why parser options work the way they do"
Since you generally will parse an entire file with the same parser options,
it's silly to have to determine the options used (and fill-in the defaults
for unspecified options) on every call to  \f(CWread()\fR.  So instead, if
you want to provide parser options, you specify them in a call to 
\f(CWmakeOpts()\fR: this method will \*(L"compile\*(R" your options for fastest-possible
usage, and then return a parser-options \*(L"object\*(R" to you which you can
plug into \f(CWread()\fR.
.SH "DIAGNOSTICS"
If a Text::Bib:: method returns an error value (usually undef), you can get
the last error by using any of these forms:
.PP
.Vb 8
\&    # If you happen to be using Bib objects:
\&    Text::Bib->lastError();
\&    
\&    # If you happen to be using MyBibSubclass objects:
\&    MyBibSubclass->lastError();
\&    
\&    # If you happen to have an instance on hand:
\&    $bibobject->lastError();
.Ve
It doesn't matter which form you use: they're all equivalent.
All return a string representation of the last error, which will
look like this:
.PP
.Vb 1
\&    "syntax: unexpected end of file"
.Ve
The error message will always be of the form \f(CW"category: description"\fR,
where the currently-legal categories include...
.PP
.Vb 2
\&    ok       not really an error: e.g., expected end-of-file
\&    syntax   syntax error in parsing
.Ve
\fBNOTE:\fR This error string is for diagnostics only: you shouldn't depend
on it for flow-control.
.SH "PERFORMANCE"
Tolerable... barely.  Even with a lot of hacking to speed things up,
it parses a typical 500 KB \fI.bib\fR file (of 1600 records) in 13
seconds of user time on my 66 MHz/32 MB RAM/I486 box running Linux 1.1.18.
So, figure about 125 records/sec, or about 40 KB/sec.
.PP
By contrast, a C program which does the same work is about 8 times
as fast.  But of course, the C code is 8 times as large, and 8 times
as ugly.  :\-)
.PP
Since the parsing doesn't really \*(L"need\*(R" regular expressions, I'm
willing to bet that a variation of the parser which uses
dynamically-loaded C functions would be a little faster.  Perhaps such
an alternate parser-method would be a parser-option, available for
people who've compiled their Perl5 to support dynamic-loading.  But,
for now, we go with a more-portable approach.
.PP
Bottom line: I'd recommend using this module to \fIprocess\fR \fI.bib\fR files, 
but if you're looking for query tool... well... maybe we need someone
to implement a \f(CWreadInfo()\fR substitute in C, which this module could
load.
.SH "NOTE TO SERIOUS BIB\-FILE USERS"
I actually do not use \fI.bib\fR files for *roffing... I used them as a
quick-and-dirty database for WebLib, and that's where this code comes
from.  If you're a serious user of \fI.bib\fR files, and this module doesn't
do what you need it to, please contact me: I'll add the functionality
in.
.SH "BUGS"
Compiles a lot of storage/access methods that the user may not need
(e.g., \fIauthors()\fR, \fIsetAuthors()\fR, etc.).  In the future, the creation of
these methods should be done on-demand, by a custom AUTOLOAD routine.
.PP
To speed up the access/storage methods calls, the full methods are created
and loaded (as opposed to having one-line \*(L"stubs\*(R" which call some 
generic \*(L"back-end\*(R" function).  The access/storage methods are pretty small,
but still... this means that all the more Perl code must be eval'ed and
loaded, and it may or may not have been a good design choice.
.PP
If any of the auto-compiled storage/access methods are invoked improperly,
the error messages are \fIvery\fR cryptic, since the \*(L"filename\*(R" mentioned
is \*(L"eval\*(R".
.PP
Some combinations of parser-options are silly.
.SH "VERSION"
$Id: Bib.pm,v 1.18 1995/12/21 19:26:41 eryq Exp $
.SH "AUTHOR"
Copyright (C) 1995 by Eryq. 
The author may be reached at 
.PP
.Vb 1
\&    eryq@rhine.gsfc.nasa.gov
.Ve
.SH "NO WARRANTY"
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.PP
For a copy of the GNU General Public License, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

.rn }` ''
